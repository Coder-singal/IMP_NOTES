import threading
counter = 0
lock = threading.Lock()
def increment_counter():
    global counter
    for _ in range(100000):
        with lock:
            counter += 1
t1 = threading.Thread(target=increment_counter)
t2 = threading.Thread(target=increment_counter)
t1.start()
t2.start()
t1.join()
t2.join()
print("Final Counter:", counter)

import threading
def thread_function(name):
    print(f"Thread {name} is running")
threads = []
for i in range(1, 3):
    t = threading.Thread(target=thread_function, args=(i,))
    threads.append(t)
    t.start()
for t in threads:
    t.join()
print("Main thread finished")


#producer consumer
import threading
import time
from collections import deque

BUFFER_SIZE = 5
buffer = deque()

lock = threading.Lock()
not_empty = threading.Condition(lock)
not_full = threading.Condition(lock)

def producer():
    item = 0
    for _ in range(10):
        with not_full:
            while len(buffer) == BUFFER_SIZE:
                not_full.wait()

            buffer.append(item)
            print(f"Produced: {item}")
            item += 1

            not_empty.notify()

        time.sleep(1)

def consumer():
    for _ in range(10):
        with not_empty:
            while not buffer:
                not_empty.wait()

            item = buffer.popleft()
            print(f"Consumed: {item}")

            not_full.notify()

        time.sleep(1)

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)

t1.start()
t2.start()

t1.join()
t2.join()
